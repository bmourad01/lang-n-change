(* extend the grammar for references *)
Expression e ::= ... | ("address" [$a.]) | ("unit" []) | ("ref" [$e.]) | ("deref" [$e.]) | ("assign" [$e, $e]) | ("seq" [$e, $e]).;
Value v ::= ... | ("address" [$a.]) | ("unit" []).;
Type T ::= ... | ("unitT" []) | ("refT" [$T.]).;
Context E ::= ... | ("ref" [$E.]) | ("deref" [$E.]) | ("assign" [$E, $e]) | ("assign" [$v, $E]) | ("seq" [$E, $e]).;
Memory m ::= [<[$a, $v]>...].;
Store Sigma ::= [<[$a, $T]>...].;

(* references are always invariant *)
# variance: ... | refT => inv;

(* modify the shape of the typing relation *)
set_relations(relations(keep)[|("typeof", [$Gamma, $e, $T])|]: ("typeof", [<[$Gamma, $Sigma]>, $e, $T]));

(* modify the shape of the step relation *)
set_relations(relations(keep)[|("step", [$e, $e])|]: ("step", [<[$e, $m]>, <[$e, $m]>]));

(* modify all typing judgements in rules to have the new shape *)
lift (gamma |- e : t) to (<[gamma, $Sigma]> |- e : t).;

(* modify the shape of reduction rules *)
lift (e1 --> e2) to (<[e1, $m]> --> <[e2, $m]>).;

(* modify the shape of reduction rules *)
set_rules(rules >>! <[e1, _]> --> <[e2, _]> >>
  (* any steps that appear in the premises must produce
   * a fresh memory which is then used in the next step *)
  let step_prems = premises(self) >> _ --> _ >> self in
  let concl = conclusion(self) in
  let steps = step_prems @ [concl.] in
  let stores = steps >> _ >> fresh_var("m") in
  let smap1 = zip(steps, stores) in
  let smap2 = zip(step_prems, tail(stores)) in 

  [rule_name(self)] {
    premises(self) >>! <[e1, _]> --> <[e2, _]> >>
      let m1 = get(assoc(self, smap1)) in
      let m2 = get(assoc(self, smap2)) in
      <[e1, m1]> --> <[e2, m2]>
    ---------------------------------------------------------
    <[e1, head(stores)]> --> <[e2, get(assoc(concl, smap1))]>
  }
);

(* add the typing rules for the new top-level operators *)

let assume = head(relations >> ("typeof", a :: _) >> a) in

add_rule(["T-ADDRESS"] {
  &member <[$a, $T]> $Sigma
  --------------------------------------------
  assume |- ("address" [$a.]) : ("refT" [$T.])
});

add_rule(["T-UNIT"] {
  ------------------------------------
  assume |- ("unit" []) : ("unitT" [])
});

add_rule(["T-REF"] {
  assume |- $e : $T
  ----------------------------------------
  assume |- ("ref" [$e.]) : ("refT" [$T.])
});

add_rule(["T-DEREF"] {
  assume |- $e : ("refT" [$T.])
  ------------------------------
  assume |- ("deref" [$e.]) : $T
});

add_rule(["T-ASSIGN"] {
  assume |- $e1 : ("refT" [$T.]),
  assume |- $e2 : $T
  ----------------------------------------------
  assume |- ("assign" [$e1, $e2]) : ("unitT" [])
});

add_rule(["T-SEQ"] {
  assume |- $e1 : ("unitT" []),
  assume |- $e2 : $T
  ---------------------------------
  assume |- ("seq" [$e1, $e2]) : $T
});

(* add the reduction rules for the new top-level operators *)

add_rule(["R-REFV"] {
  &($a = $fresh($dom($m)))
  ------------------------------------------------------------
  <[("ref" [$v.]), $m]> --> <[("address" [$a.]), [$a => $v]$m]>
});

add_rule(["R-DEREF"] {
  &member <[$a, $v]> $m
  -----------------------------------------------------
  <[("deref" [("address" [$a.]).]), $m]> --> <[$v, $m]>
});

add_rule(["R-ASSIGN"] {
  &member $a $dom($m)
  ----------------------------------------------------------------------------
  <[("assign" [("address" [$a.]), $v]), $m]> --> <[("unit" []), [$a => $v]$m]>
});

add_rule(["R-SEQ"] {
  ------------------------------------------------
  <[("seq" [("unit" []), $e]), $m]> --> <[$e, $m]>
});

(* add the relation to check the memory for well-formedness *)

add_relation("memory_ok", [$Sigma, $m]);

# mode: ... | memory_ok => inp inp;
# principal: ... | memory_ok => no yes;

add_rule(["MEMORY-OK-NIL"] {
  ----------------------------
  &("memory_ok" [$Sigma, $nil])
});

let mem_assume = match assume with <_ :: ts> -> <$nil :: ts> in

add_rule(["MEMORY-OK"] {
  mem_assume |- $v : $T,
  &member <[$a, $T]> $Sigma,
  &("memory_ok" [$Sigma, $m])
  ------------------------------------------
  &("memory_ok" [$Sigma, $(<[$a, $v]> :: $m)])
})
