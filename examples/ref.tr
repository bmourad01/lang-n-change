(* extend the grammar for references *)
Expression e ::= ... | ("address" [$a.]) | ("unit" []) | ("ref" [$e.]) | ("deref" [$e.]) | ("assign" [$e, $e]) | ("seq" [$e, $e]).;
Value v ::= ... | ("address" [$a.]) | ("unit" []).;
Type T ::= ... | ("unitT" []) | ("refT" [$T.]).;
Context E ::= ... | ("ref" [$E.]) | ("deref" [$E.]) | ("assign" [$E, $e]) | ("assign" [$v, $E]) | ("seq" [$E, $e]).;
Memory m ::= {a => $v}.;
Store Sigma ::= {a => $T}.;

(* references are always invariant *)
# variance: ... | refT => inv;

(* modify the shape of the typing relation *)
set_relations(relations >>! ("typeof", [a, e, t]) >>
  match a with
  | <ts> -> ("typeof", [<ts @ [$Sigma.]>, e, t])
  | _ -> ("typeof", [<[a, $Sigma]>, e, t])
);

(* modify the shape of the step relation *)
set_relations(relations >>! ("step", [t1, t2]) >>
  match (t1, t2) with
  | (<ts1>, <ts2>) -> ("step", [<ts1 @ [$m.]>, <ts2 @ [$m.]>])
  | _ -> ("step", [<[t1, $m]>, <[t2, $m]>])
);

(* modify all typing judgements in rules to have the new shape *)
set_rules(rules >>! gamma |- e : t >>
  let do_gamma (g: term) : term = match g with
    | <ts> -> <ts @ [$Sigma.]>
    | _ -> <[g, $Sigma]>
  in

  [rule_name(self)] {
    premises(self) >>! gamma |- e : t >>
      do_gamma(gamma) |- e : t
    ---------------------------
    do_gamma(gamma) |- e : t
  }
);

(* modify the shape of reduction rules *)
set_rules(rules >>! e1 --> e2 >>
  let do_config (c: term) (m: term) : term = match c with
    | <ts> -> <ts @ [m.]>
    | _ -> <[c, m]>
  in
  
  (* any steps that appear in the premises must produce
   * a fresh memory which is then used in the next step *)
  let step_prems = premises(self) >> e1 --> e2 >> self in
  let concl = conclusion(self) in
  let steps = step_prems @ [concl.] in
  let stores = steps >> _ >> fresh_var("m") in
  let smap1 = zip(steps, stores) in
  let smap2 = zip(step_prems, tail(stores)) in 

  [rule_name(self)] {
    premises(self) >>! e1 --> e2 >>
      (let c1 = do_config(e1, get(assoc(self, smap1))) in
       let c2 = do_config(e2, get(assoc(self, smap2))) in
       c1 --> c2)
    ---------------------------------------------------
    let c1 = do_config(e1, head(stores)) in
    let c2 = do_config(e2, get(assoc(concl, smap1))) in
    c1 --> c2
  }
);

(* add the typing rules for the new top-level operators *)

let assume = head(relations >> ("typeof", a :: _) >> a) in

add_rule(["T-ADDRESS"] {
  &member <[$a, $T]> $Sigma
  --------------------------------------------
  assume |- ("address" [$a.]) : ("refT" [$T.])
});

add_rule(["T-UNIT"] {
  ------------------------------------
  assume |- ("unit" []) : ("unitT" [])
});

add_rule(["T-REF"] {
  assume |- $e : $T
  ----------------------------------------
  assume |- ("ref" [$e.]) : ("refT" [$T.])
});

add_rule(["T-DEREF"] {
  assume |- $e : ("refT" [$T.])
  ------------------------------
  assume |- ("deref" [$e.]) : $T
});

add_rule(["T-ASSIGN"] {
  assume |- $e1 : ("refT" [$T.]),
  assume |- $e2 : $T
  ----------------------------------------------
  assume |- ("assign" [$e1, $e2]) : ("unitT" [])
});

add_rule(["T-SEQ"] {
  assume |- $e1 : ("unitT" []),
  assume |- $e2 : $T
  ---------------------------------
  assume |- ("seq" [$e1, $e2]) : $T
});

(* add the reduction rules for the new top-level operators *)

let config = head(relations >> ("step", a :: _) >> a) in

let do_config (t: term) (m: term) =
  match config with <ts> ->
    let ts = tail(diff(ts, [$m.])) in
    <t :: (ts @ [m.])>
in

add_rule(
  let lhs = ("ref" [$v.]) in
  let rhs = ("address" [$a.]) in

  ["R-REFV"] {
    &($a = $fresh($dom($m)))
    ---------------------------------------------------
    do_config(lhs, $m) --> do_config(rhs, [$a => $v]$m)
  }
);

add_rule(
  let lhs = ("deref" [("address" [$a.]).]) in

  ["R-DEREF"] {
    &member <[$a, $v]> $m
    ----------------------------------------
    do_config(lhs, $m) --> do_config($v, $m)
  }
);

add_rule(
  let lhs = ("assign" [("address" [$a.]), $v]) in
  let rhs = ("unit" []) in

  ["R-ASSIGN"] {
    &member $a $dom($m)
    ---------------------------------------------------
    do_config(lhs, $m) --> do_config(rhs, [$a => $v]$m)
  }
);

add_rule(
  let lhs = ("seq" [("unit" []), $e]) in  

  ["R-SEQ"] {
    ----------------------------------------
    do_config(lhs, $m) --> do_config($e, $m)
  }
);

(* add the relation to check the memory for well-formedness *)

add_relation("memory_ok" [$Sigma, $m]);

# mode: ... | memory_ok => inp inp;
# principal: ... | memory_ok => no yes;

add_rule(["MEMORY-OK-NIL"] {
  ---------------------------
  &("memory_ok" [$Sigma, $nil])
});

let mem_assume = match assume with <_ :: ts> -> <$nil :: ts> in

add_rule(["MEMORY-OK"] {
  mem_assume |- $v : $T,
  &member <[$a, $T]> $Sigma,
  &("memory_ok" [$Sigma, $m])
  ------------------------------------------
  &("memory_ok" [$Sigma, $(<[$a, $v]> :: $m)])
})
