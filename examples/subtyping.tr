(* modify all typing rules *)
set_rules(rules >> _ >> (
  let typ_prems = premises(self) >> &("typeof" _) >> self in
  if empty?(typ_prems) then self else
    (* uniquify all type variables in the outputs;
     * this will return a list of modified premises
     * and a map from the original types to a list of
     * their uniquified counterparts *)
    let (new_premises, tmap) =
      let ignored = premises(self) >> _ >>
        match self with
        | _ |- _ : _[_/x] -> some(self)
        | _ -> none
      in
      uniquify(premises(self), ignored, hint("mode"), "out")
    in

    (* replace the premises with the uniquified ones *)
    let r = [rule_name(self)] {
      new_premises
      ------------------
      conclusion(self)
    } in
    
    (* grab all types in contravariant positions *)
    let contra_types = concat(
      premises(r) >> gamma |- e : t >>
        let rec aux (t: term) : term list = match t with
          | (c ts) ->
            (match assoc(c, hint("variance")) with
             | none -> []
             | some(variance) ->
               let vmap = zip(ts, variance) in
               (vmap >> (t, v) >> if v = "contra" then some(t) else none))
             @ concat(ts >> t >> aux(t))
          | _ -> []
        in dedup(aux(t)))
    in
   
    (* grab all types in invariant positions *)
    let inv_types = concat(
      premises(r) >> p >> match p with
      | gamma |- e : (c ts) ->
        (match assoc(c, hint("variance")) with
         | none -> []
         | some(variance) ->
           let vmap = zip(ts, variance) in
           (vmap >> (t, v) >> if v = "inv" then some(t) else none))
      | &member t _ ->
        (* is this correct? *)
        (vars(t) >> t >> if var_kind?(t, "Type") then some(t) else none)
      | _ -> [])
    in
    
    (* create a map from the original types (before uniquify)
     * to the "final type" that should appear in the conclusion *)
    let final_type = concat(
      tmap >> (tk, tv) >> (
        match conclusion(r) with
        | gamma |- e : t ->
          let t_types = vars(t) >> v >>
            (if var_kind?(v, "Type") then some(v) else none)
          in
          if empty?(t_types) then none else
            some(concat(vars(e) >> v >>
              match assoc(v, tmap) with
              | none ->
                 let ov = dedup(concat(concat(
                   tv >> t >> (contra_types >> c >> var_overlap(t, c)))))
                 in
                 if empty?(ov)
                 then zip([tk.], [tk.])
                 else zip([tk.], ov)
              | some(_) -> zip([tk.], [v.])))
        | _ -> none))
    in
   
    (* for each type we uniquified, get their uniquified
     * counterparts and interleave them in a list of pairs,
     * then use these pairs to append new subtyping premises *) 
    let tpairs = concat(tmap >> (_, ts) >> interleave_pairs(ts)) in
    let r = [rule_name(r)] {
      premises(r),
      tpairs >> (t1, t2) >> t1 <: t2
      ------------------------------
      conclusion(r) 
    } in 
   
    (* reorder the generated subtyping premises according
     * to their variance (i.e. did they appear in a
     * contravariant/invariant position in the premises?) *) 
    let r = [rule_name(r)] {
      premises(r) >>! t1 <: t2 >> (
        let p = self in
        let ps = premises(r) >> gamma |- e : (c ts) >> (
          match assoc(c, hint("variance")) with
          | none -> none
          | some(variance) ->
            let vmap = zip(ts, variance) in
            match assoc(t1, vmap) with
            | some("contra") -> some(t2 <: t1)
            | some("inv") ->
              (match assoc(t2, vmap) with
               | some("inv") -> some(&(t1 = t2))
               | _ -> some(t2 <: t1))
            | _ -> none)
        in if empty?(ps) then p else head(ps))
      ---------------------------------------
      conclusion(r)
    } in
    
    (* check for types that are peers, and if so, add a join for them *) 
    let r = [rule_name(r)] {
      premises(r),
      tmap >> (tk, tv) >> (
        let ov = dedup(concat(concat(
          tv >> t >> (contra_types >> c >> var_overlap(t, c)))))
        in
        if not(empty?(ov)) then none else
          let ov = dedup(concat(concat(
            tv >> t >> (inv_types >> c >> var_overlap(t, c)))))
          in
          if empty?(ov)
          then some(&("join" (tv @ [tk.])))
          else
            let final_type_range = final_type >> (_, v) >> v in
            if member?(tk, final_type_range)
            then some(&("join" (tv @ [tk.])))
            else none)
      -----------------------
      conclusion(r)
    } in
    
    (* substitute the final type in the rule *)
    let r = substitute(r, final_type) in
    
    (* eliminate subtyping premises that are subsumed by a join *)
    let r = [rule_name(r)] {
      premises(r) >>! t1 <: t2 >> (
        let joins = premises(r) >> &("join" ts) >> (
          let ov1 = dedup(concat(ts >> t >> var_overlap(t1, t))) in
          let ov2 = dedup(concat(ts >> t >> var_overlap(t2, t))) in
          if empty?(ov1) || empty?(ov2) then none else some(self))
        in
        if empty?(joins) then some(self) else none)
      --------------------------------------------
      conclusion(r)
    } in
    
    r
));

(* add the relation for the join of types *)
add_rules(syntax("Type") >> (c ts) >>
  let vmap = match assoc(c, hint("variance")) with  
    | none -> []
    | some(variance) -> zip(ts, variance)
  in
  
  ["JOIN-" ^ uppercase(c)] {
    concat(ts >> t >> (
      let tu = unbind(t) in
      match assoc(t, vmap) with
      | some("contra") -> [&("meet" [tu, tu', tu'']).]
      | some("inv") -> [&(tu = tu'), &(tu'' = tu)]
      | _ -> [&("join" [tu, tu', tu'']).]))
    ---------------------------------------
    &("join" [(c ts), (c ts'), (c ts'')])
  }
);

(* add the relation for the meet of types *)
add_rules(syntax("Type") >> (c ts) >>
  let vmap = match assoc(c, hint("variance")) with  
    | none -> []
    | some(variance) -> zip(ts, variance)
  in

  ["MEET-" ^ uppercase(c)] {
    concat(ts >> t >> (
      let tu = unbind(t) in
      match assoc(t, vmap) with
      | some("contra") -> [&("join" [tu, tu', tu'']).]
      | some("inv") -> [&(tu = tu'), &(tu'' = tu)]
      | _ -> [&("meet" [tu, tu', tu'']).]))
    ---------------------------------------
    &("meet" [(c ts), (c ts'), (c ts'')])
  }
);

(* add the relation for subtyping *)
add_rules(syntax("Type") >> (c ts) >>
  let vmap = match assoc(c, hint("variance")) with  
    | none -> []
    | some(variance) -> zip(ts, variance)
  in

  ["S-" ^ uppercase(c)] {
    ts >> t >> (
      let tu = unbind(t) in
      match assoc(t, vmap) with
      | some("contra") -> tu' <: tu
      | some("inv") -> &(tu = tu')
      | _ -> tu <: tu')
    ----------------------------
    (c ts) <: (c ts')
  }
);

add_relation("join" [$T, $T, $T]);
add_relation("meet" [$T, $T, $T]);
add_relation($T <: $T);

# mode: ... | join => inp inp out | meet => inp inp out | subtype => inp inp;
# principal: ... | join => yes yes no | meet => yes yes no | subtype => yes yes;

(* add the cast operator to the grammar for expressions, contexts *)
Expression e ::= ... | ("cast" [$e, $T]).;
Context E ::= ... | ("cast" [$E, $T]).;

(* add the typing rule for casts *)
add_rule(
  let assume = head(relations >> ("typeof", a :: _) >> a) in
  ["T-CAST"] {
    assume |- $e : $T',
    $T' <: $T
    ---------------------------------
    assume |- ("cast" [$e, $T]) : $T
  }
);

(* add the reduction rule for casts *)
add_rule(
  let config = head(relations >> ("step", a :: _) >> a) in
  let do_config (t: term) = match config with
    | <_ :: ts> -> <t :: ts>
    | $!_ -> t
  in
  
  ["R-CAST"] {
    ----------------------------------------------
    do_config(("cast" [$v, $T])) --> do_config($v)
  }
)
