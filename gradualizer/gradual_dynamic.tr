Type T ::= ... | ("dyn" []).;
Expression e ::= ... | ("gcast" [$e, $T, $T, $L]).;
Context E ::= ... | ("gcast" [$E, $T, $T, $L]).;
Error er ::= ... | ("blame" [$G, $L]).;

Value v ::= {
  let casts = Type[`(c ts)` when not(empty?(ts))]:
    ("gcast" [$v, (c ts), (c ts), $L])
  in
  Value @ casts @ [("gcast" [$v, $G, ("dyn" []), $L]).]
};

Ground G ::= {
  Type[`(c ts)` when not(c = "dyn")]:
    let dyns = ts[`t`]: if binding?(t) then t else ("dyn" []) in
    (c dyns)
};

["T-GCAST"] {
  $Gamma |- $e : $T1,
  $T1 ~ $T2
  --------------------------------------------
  $Gamma |- ("gcast" [$e, $T1, $T2, $L]) : $T2
};

add_relation($T ~ $T);

# mode: ... | consistent => inp inp;
# principal: ... | consistent => yes yes;

(Type[`(c ts)`]:
  ["C-" ^ uppercase(c)] {
    ts[`t`]: unbind(t) ~ unbind(t)'
    -------------------------------
    (c ts) ~ (c ts')
  }
);

["C-T-DYN"] {
  ----------------
  $T ~ ("dyn" [])
};
    
["C-DYN-T"] {
  ----------------
  ("dyn" []) ~ $T
};

(Type[`(c ts)` when not(empty?(ts))]:
  ["R-GCAST-" ^ uppercase(c)] {
    -----------------------------------------
    ("gcast" [$v, (c ts), (c ts), $L]) --> $v
  }
);

["R-GCAST-GCAST-OK"] {
  ---------------------------------------------------------------------------
  ("gcast" [("gcast" [$v, $G, ("dyn" []), $L1]), ("dyn" []), $G, $L2]) --> $v
};

["R-GCAST-GCAST-ERROR"] {
  &($G1 =/= $G2)
  -----------------------------------------------------------------------------------------------
  ("gcast" [("gcast" [$v, $G1, ("dyn" []), $L1]), ("dyn" []), $G2, $L2]) --> ("blame" [$G2, $L2])
};

["R-GCAST-T-TO-DYN"] {
  &($T =/= $G),
  &($T =/= ("dyn" [])),
  $T ~ $G
  -------------------------------------------------------------------------------------------------
  ("gcast" [$v, $T, ("dyn" []), $L]) --> ("gcast" [("gcast" [$v, $T, $G, $L]), $G, ("dyn" []), $L])
};

["R-GCAST-DYN-TO-T"] {
  &($T =/= $G),
  &($T =/= ("dyn" [])),
  $T ~ $G
  -------------------------------------------------------------------------------------------------
  ("gcast" [$v, ("dyn" []), $T, $L]) --> ("gcast" [("gcast" [$v, ("dyn" []), $G, $L]), $G, $T, $L])
};

hint("eliminationform")[`(op, pa)`]:
  let r = head(Rule[`_ |- (opp _) : _` when op = opp]: self) in
  let idx = str_int(head(pa)) in
  let typing_prems = premises(r)[`gamma |- e : t`]: self in
  match conclusion(r) with gamma |- (op es) : t ->
  let elim_e = nth(es, idx) in
  let pa_type = head(typing_prems[`_ |- e : (c ts)` when e = elim_e]: (c ts)) in
  match pa_type with (c ts) ->
  if empty?(ts) then none      
  else
    let cast_map = typing_prems[`gamma |- e : t` when not(e = elim_e)]: (e, t) in
    let siblings_lhs = keys(cast_map) in
    let siblings_rhs = cast_map[`(e, t)`]: ("gcast" [e, t, t', $L]) in
    let add_subs = typing_prems[`([$!x => t1]gamma) |- e : t2`]:
      (e, e{("gcast" [$!x, t1'|vars(pa_type), t1, $L])/x})
    in
    let tas = vars(es)[`t` when var_kind?(t, "Type")]: t in
    let tas_p = tas'|vars(pa_type) in
    let siblings_lhs = substitute(siblings_lhs, add_subs) in
    let siblings_rhs = substitute(siblings_rhs, add_subs) in
    let turn_to_value = concat(Rule[`(opp ts) --> _` when op = opp]:
      zip(es, ts)[`(t1, t2)` when var?(t2) && var_kind?(t2, "Value")]: self)
    in
    let siblings_lhs = substitute(siblings_lhs, turn_to_value) in
    let siblings_rhs = substitute(siblings_rhs, turn_to_value) in
    let t_p = t'|vars(pa_type) in
    let pa_v = fresh_var("v") in
    let target = 
      let e = (op (tas_p @ [pa_v.] @ siblings_rhs)) in
      if t = t_p then e else ("gcast" [e, t_p, t, $L])
    in
    some(["R-ELIM-GCAST-" ^ uppercase(op)] {
       ----------------------------------------------------------------------
       (op (tas @ [("gcast" [pa_v, pa_type', pa_type, $L]).] @ siblings_lhs)) --> target
    })
