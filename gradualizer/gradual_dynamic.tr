Type T ::= ... | ("dyn" []).;
Expression e ::= ... | ("gcast" [$e, $T, $T]).;
Context E ::= ... | ("gcast" [$E, $T, $T]).;

Value v ::= {
  let casts = syntax("Type")[`(c ts)` when not(empty?(ts))]:
    ("gcast" [$v, (c ts), (c ts)])
  in
  syntax("Value") @ casts @ [("gcast" [$v, $G, ("dyn" [])]).]
};

Ground G ::= {
  syntax("Type")[`(c ts)` when not(c = "dyn")]:
    let dyns = ts[`t`]: if binding?(t) then t else ("dyn" []) in
    (c dyns)
};

add_rule(["T-GCAST"] {
  $Gamma |- $e : $T1,
  $T1 ~ $T2
  ---------------------------------------
  $Gamma |- ("gcast" [$e, $T1, $T2]) : $T2
});

add_relation($T ~ $T);

# mode: ... | consistent => inp inp;
# principal: ... | consistent => yes yes;

add_rules(syntax("Type")[`(c ts)`]:
  ["C-" ^ uppercase(c)] {
    ts[`t`]: unbind(t) ~ unbind(t)'
    -------------------------------
    (c ts) ~ (c ts')
  }
);

add_rule(["C-T-DYN"] {
  ----------------
  $T ~ ("dyn" [])
});
    
add_rule(["C-DYN-T"] {
  ----------------
  ("dyn" []) ~ $T
});

add_rules(syntax("Type")[`(c ts)` when not(empty?(ts))]:
  ["R-GCAST-" ^ uppercase(c)] {
    ------------------------------------
    ("gcast" [$v, (c ts), (c ts)]) --> $v
  }
);

add_rule(["R-GCAST-GCAST-OK"] {
  --------------------------------------------------------------
  ("gcast" [("gcast" [$v, $G, ("dyn" [])]), ("dyn" []), $G]) --> $v
});

add_rule(["R-GCAST-GCAST-ERROR"] {
  &($G1 =/= $G2)
  -------------------------------------------------------------------------
  ("gcast" [("gcast" [$v, $G1, ("dyn" [])]), ("dyn" []), $G2]) --> ("err" [])
});

add_rule(["R-GCAST-T-TO-DYN"] {
  &($T =/= $G),
  &($T =/= ("dyn" [])),
  $T ~ $G
  ----------------------------------------------------------------------------------
  ("gcast" [$v, $T, ("dyn" [])]) --> ("gcast" [("gcast" [$v, $T, $G]), $G, ("dyn" [])])
});

add_rule(["R-GCAST-DYN-TO-T"] {
  &($T =/= $G),
  &($T =/= ("dyn" [])),
  $T ~ $G
  ----------------------------------------------------------------------------------
  ("gcast" [$v, ("dyn" []), $T]) --> ("gcast" [("gcast" [$v, ("dyn" []), $G]), $G, $T])
});

let typing_rule_of_op (op: string) =
  head(rules[`gamma |- (opp _) : _` when op = opp]: self)
in

let filter_ts (ts: term list) =
  ts[`t` when var?(t) && var_kind?(t, "Type")]: self
in

add_rules(hint("eliminationform")[`(op, pa)`]:
  let r = typing_rule_of_op(op) in
  let idx = str_int(head(pa)) in
  let typing_prems = premises(r)[`gamma |- e : t`]: self in
  match conclusion(r) with gamma |- (op es) : t ->
  let elim_e = nth(es, idx) in
  let pa_type = head(typing_prems[`_ |- e : (c ts)` when e = elim_e]: (c ts)) in
  match pa_type with (c ts) ->
  if empty?(ts) then none      
  else
    let cast_map = typing_prems[`gamma |- e : t` when not(e = elim_e)]: (e, t) in
    let siblings = cast_map[`(e, t)`]: ("gcast" [e, t, t']) in
    let add_subs = typing_prems[`([$!x => t1]gamma) |- e : t2`]:
      (e, e{("gcast" [$!x, t1'|vars(pa_type), t1])/x})
    in
    let tas = filter_ts(vars(es)) in
    let tas_p = tas'|vars(pa_type) in
    let siblings = substitute(siblings, add_subs) in
    let turn_to_value = concat(rules[`(opp ts) --> _` when op = opp]:
      zip(es, ts)[`(t1, t2)` when var?(t2) && var_kind?(t2, "Value")]: (t1, t2))
    in
    let siblings = substitute(siblings, turn_to_value) in
    let t_p = t'|vars(pa_type) in
    let target = 
      let e = (op (tas @ [$v.] @ siblings)) in
      if t = t_p then e else ("gcast" [e, t_p, t])
    in
    some(["R-ELIM-GCAST-" ^ uppercase(op)] {
       ----------------------------------------------------------------------
       (op (tas @ [("gcast" [$v, pa_type', pa_type]).] @ siblings)) --> target
    }))
