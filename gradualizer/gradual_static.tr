(* add the cast operator and the dynamic type *)
Expression e ::= ... | ("gcast" [$e, $T, $T]).;
Context E ::= ... | ("gcast" [$E, $T, $T]).;
Type T ::= ... | ("dyn" []).;

Value v ::= {
  let casts = syntax("Type")[`(c ts)` when not(empty?(ts))]:
    ("cast" [$v, (c ts), (c ts)])
  in
  syntax("Value") @ casts @ [("cast" [$v, $G, ("dyn" [])]).]
};

(* add ground types *)
Ground G ::= {
  syntax("Type")[`(c ts)` when not(c = "dyn")]:
    let dyns = ts[`t`]: if binding?(t) then t else ("dyn" []) in
    some((c dyns))
};
    
let is_typ_var (t: term) = var?(t) && var_kind?(t, "Type") in
let is_exp_var (t: term) = var?(t) && var_kind?(t, "Expression") in
let filter_ts (ts: term list) = ts[`t` when is_typ_var(t)]: t in
let filter_es (ts: term list) = ts[`t` when is_exp_var(t)]: t in

(* define the consistency, pattern-matching, join, and static relations *)
add_relation($T ~ $T);
add_relation("matches", [$T, $T]);
add_relation("gjoin", [$T, $T, $T]);
add_relation("static", [$T.]);

# mode: ... | consistent => inp inp | matches => inp out | gjoin => inp inp out | static => inp;
# principal: ... | consistent => yes yes | matches => yes no | gjoin => yes yes no | static => yes;
    
add_rules(syntax("Type")[`(c ts)`]:
  ["C-" ^ uppercase(c)] {
    ts[`t`]: unbind(t) ~ unbind(t)'
    -------------------------------
    (c ts) ~ (c ts')
  }
);

add_rule(["C-T-DYN"] {
  ----------------
  $T ~ ("dyn" [])
});
    
add_rule(["C-DYN-T"] {
  ----------------
  ("dyn" []) ~ $T
});

add_rules(syntax("Type")[`(c ts)` when not(c = "dyn")]: 
  let ts = ts[`t`]: if binding?(t) then $(bound(t))("dyn" []) else ("dyn" []) in
  ["MATCHES-DYN-" ^ uppercase(c)] {
    ---------------------------------
    &("matches" [("dyn" []), (c ts)])
  }
);

add_rules(syntax("Type")[`(c ts)` when not(c = "dyn")]:
  ["MATCHES-" ^ uppercase(c)] {
    -----------------------------
    &("matches" [(c ts), (c ts)])
  }
);

add_rules(syntax("Type")[`(c ts)` when not(c = "dyn")]:
  ["STATIC-" ^ uppercase(c)] {
    ts[`t`]: &("static" [t.])
    ----------------------------
    &("static" [(c ts).])
  }
);

add_rules(syntax("Type")[`(c ts)` when not(c = "dyn")]:
  ["GJOIN-" ^ uppercase(c)] {
    ts[`t`]:
      let t = unbind(t) in
      &("gjoin" [t, t', t''])
    -------------------------------------
    &("gjoin" [(c ts), (c ts'), (c ts'')])
  }
);

add_rule(["GJOIN-T-DYN"] {
  ------------------------------
  &("gjoin" [$T, ("dyn" []), $T])
});
    
add_rule(["GJOIN-DYN-T"] {
  ------------------------------
  &("gjoin" [("dyn" []), $T, $T])
});

(* check if the language has subtyping *)
let has_subtyping =
  let has_relation (r: string) =
    not(empty?(relations[`(name, _)` when r = name]: self))
  in
  has_relation("subtype")
  && has_relation("join")
  && has_relation("meet")
in

(if has_subtyping then (
  (* we use the 'subtype_flow' relation instead *)
  remove_relation("subtype");
  remove_hint("mode", "subtype");
  remove_hint("principal", "subtype");
  
  (* change the shape of subtype/join/meet relations *)
  lift t1 <: t2 to t1 <: t2 ==> t1'.;
  lift &("join" [t1, t2, t3]) to &("join" [t1, t2, t3, t3']).;
  lift &("meet" [t1, t2, t3]) to &("meet" [t1, t2, t3, t3']).;
  add_relation($T <: $T ==> $T);
  add_relation("join", [$T, $T, $T, $T]);
  add_relation("meet", [$T, $T, $T, $T]);

  # mode: ... | subtype_flow => inp inp out | join => inp inp out out | meet => inp inp out out;
  # principal: ... | subtype_flow => yes yes no | join => yes yes no no | meet => yes yes no no;

  (* add some grounding rules for the new relations *)
  add_rules(concat(syntax("Type")[`(c [])` when not(c = "dyn")]:
      [["S-DYN-" ^ uppercase(c)] {
         ------------------------------
         ("dyn" []) <: (c []) ==> (c [])
       },
       ["S-" ^ uppercase(c) ^ "-DYN"] {
         ------------------------------
         (c []) <: ("dyn" []) ==> (c [])
       },
       ["JOIN-DYN-" ^ uppercase(c)] {
         ----------------------------------------------
         &("join" [("dyn" []), (c []), (c []), (c [])])
       },
       ["JOIN-" ^ uppercase(c) ^ "-DYN"] {
         ----------------------------------------------
         &("join" [(c []), ("dyn" []), (c []), (c [])])
       },
       ["MEET-DYN-" ^ uppercase(c)] {
         ----------------------------------------------
         &("meet" [("dyn" []), (c []), (c []), ("dyn" [])])
       },
       ["MEET-" ^ uppercase(c) ^ "-DYN"] {
         ----------------------------------------------
         &("meet" [(c []), ("dyn" []), (c []), ("dyn" [])])
       }]));

  add_rule(["S-DYN"] {
    ---------------------------------------
    ("dyn" []) <: ("dyn" []) ==> ("dyn" [])
  });

  add_rule(["JOIN-DYN"] {
    ---------------------------------------------------------
    &("join" [("dyn" []), ("dyn" []), ("dyn" []), ("dyn" [])])
  });

  add_rule(["MEET-DYN"] {
    ---------------------------------------------------------
    &("meet" [("dyn" []), ("dyn" []), ("dyn" []), ("dyn" [])])
  })
) else skip);

let seek
    (h: string)
    (key: string)
    (data: term list)
    (tag: string) =
  match assoc(key, hint(h)) with
  | none -> []
  | some(m) -> zip(m, data)[`(x, t)` when x = tag]: t
in

let map_merge
    (m1: (term, term list) tuple list)
    (m2: (term, term list) tuple list) =
  let m = m1[`(t, ts)`]:
    match assoc(t, m2) with
    | none -> (t, ts)
    | some(tts) -> (t, ts @ tts)
  in
  let ov = diff(m2[`(t, _)`]: t, m1[`(t, _)`]: t) in
  let rest = ov[`t`]: (t, assoc!(t, m2)) in
  m @ rest
in

(* gradualize the typing rules *)
set_rules(rules(keep)[`gamma |- e : t`]: (
  let name = rule_name(self) in
  let op = match e with (op _) -> op | _ -> "" in

  (* split equal types in the outputs *)
  let (new_premises, tmap) =
    let ignored = premises(self)[`_`]:
      match self with
      | _ |- _ : _{_/x} -> some(self)
      | _ -> none
    in
    uniquify(premises(self), ignored, hint("mode"), "out")
  in

  let not_uniquified = dedup(concat(premises(self)[`&(pred ts)`]:
    let outs = seek("mode", pred, ts, "out") in
    filter_ts(vars(outs))[`t` when not(assoc?(t, tmap))]: self))
  in
  let tmap = map_merge(tmap, not_uniquified[`t`]: (t, [t.])) in

  let r = [name] {
    new_premises
    ------------------
    conclusion(self)
  } in
    
  let tmap = map_merge(tmap, filter_ts(vars(e))[`t`]: (t, [t.])) in
  let tmap_inverse = concat(tmap[`(t, ts)`]: ts[`_`]: (self, t)) in

  (* find producers, consumers, and final types *)
  let rec extract_contra (t: term) : term list =
    match t with
    | (c ts) ->
      let contras = seek("variance", c, ts, "contra") in
      vars(contras) @ concat(diff(ts, contras)[`_`]: extract_contra(self))
    | _ -> []
  in
  let consumers = concat(premises(r)[`_ |- _ : t`]: extract_contra(t)) in
  let final_type = 
    let evars = vars(e) in
    tmap[`(t, ts)`]:
      if less?(length(ts), 2) then (t, t)
      else
        let ol = var_overlap(evars, ts) in
        if not(empty?(ol)) then (t, head(ol))
        else
          let ol = var_overlap(consumers, ts) in
          if not(empty?(ol)) then (t, head(ol))
          else (t, t')
  in
  let producers = diff(tmap_inverse[`(t, _)`]: t, consumers) in
  let lone_inputs = filter_ts(diff(vars(r), consumers @ producers)) in
   
  let extract_type_by_index (e: term) (n: int) =
    head(premises(r)[`_ |- ee : t` when e = ee]: nth(filter_ts(vars!(t)), n))
  in
  let consumer_type_by_user =
    match assoc(op, hint_list("flows")) with
    | none -> []
    | some(flows) ->
      concat(flows[`[e1, n1, e2, n2]`]:
        let t1 = extract_type_by_index($!e1, str_int(n1)) in
        let t2 = extract_type_by_index($!e2, str_int(n2)) in
        [(t2, t1), (t1, t1)])
  in
  
  (* mark each producer as flowing to consumers through their final type *)
  let r = [name] {
    premises(r),
    tmap[`(t, ts)`]:
      if less?(length(ts), 2) then none
      else some(&("gjoin" (ts @ [t'.]))),
    dedup(concat(tmap_inverse[`(t1, t2)`]: (
      let tuser = assoc(t1, consumer_type_by_user) in
      let tfinal =
        match tuser with
        | none -> assoc!(t2, final_type)
        | some(t) -> t
      in
      let tcons = var_overlap(assoc!(t2, tmap), consumers) in
      let flowfinal = &("flows" [t1, tfinal]) in
      let flowcons = match tcons with
        | [] -> []
        | t :: _ ->
          let t = if none?(tuser) then t else get(tuser) in
          [&("flows" [tfinal, t]).]
      in
      flowfinal :: flowcons)))
    ---------------------------------------------------------
    conclusion(r)
  } in
  
  (* replace each input by its final type *)
  let r =
    let flowc =
      match assoc(op, hint_list("flows")) with
      | none -> []
      | some(flows) -> flows[`[_, "c", _, _, _]`]: self
    in
    if empty?(flowc) then substitute(r, final_type)
    else
      let prev_vars = tmap_inverse[`(t, _)`]: t in
      let (new_concl, tmap) = 
        uniquify([conclusion(r).], [], hint("mode"), "out", prev_vars)
      in
      let inputmap = flowc[`[t, _, n1, e, n2]`]:
        let t1 = nth(assoc!($!t, tmap), str_int(n1)) in
        let t2 = extract_type_by_index($!e, str_int(n2)) in
        (t1, t2)
      in
      let lonemap = concat(tmap[`(t, ts)`]:
        if member?(t, lone_inputs) then (ts[`_`]: (self, t)) else [])
      in
      set_conclusion(r, substitute(head(new_concl), lonemap @ inputmap))
  in
  
  (* use pattern matching on type constructors in the outputs and
   * restrict lone input variables to range over static types only *)
  let rec make_match (t: term) : (term, formula list) tuple =
    match t with
    | (c ts) ->
      let (new_ts, fs) = unzip(ts[`t`]: make_match(t)) in
      let fs = concat(fs) in
      let typ = fresh_var("M") in
      (typ, &("matches" [typ, (c new_ts)]) :: fs)
    | _ -> (t, [])
  in 
  let r = [name] {
    premises(r)(keep)[`gamma |- e : t`]:
      let (t, fs) = make_match(t) in
      (gamma |- e : t) :: fs,
    (* first check if the lone input was substituted *)
    lone_inputs[`t` when member?(t, vars(r)) && constructor?(e)]: &("static" [t.])
    ------------------------------------------------------------------------------
    conclusion(r)
  } in
  
  (* compile to the cast calculus *)
  let r = lift (gamma |- e : t) to (gamma |- ("ci" [e, e']) : t) in r in
  let rec destination_type (t: term) : term =
    let typs = concat(premises(r)[`f`]:
      match f with
      | t1 <: t2 ==> t3 when t1 = t -> [t3.]
      | &("join" [t1, t2, t3, t4]) when (t1 = t) || (t2 = t) -> [t4.]
      | &("meet" [t1, t2, t3, t4]) when (t1 = t) || (t2 = t) -> [t4.]
      | &("matches" [t1, (c ts)]) when t1 = t ->
        [(c (ts[`t`]: destination_type(t))).]
      | &("flows" [t1, t2]) when t2 = t ->
        if member?(t1, consumers) then [t1.] else [t.]
      | &("flows" [t1, t2]) when t1 = t -> [t2.]
      | _ -> [])
    in
    if empty?(typs) then t else head(typs)
  in
  let dests =
    if empty?(premises(r)) then []
    else vars(r)[`t`]: (t, destination_type(t))
  in
  let emap = (e, t) :: premises(r)[`_ |- ("ci" [e, _]) : t`]: (e, t) in
  let rec insert_cast (e: term) : term =
    match e with
    | (op es) -> (op (es[`e`]: insert_cast(e)))
    | _ ->
      match assoc(e, emap) with
      | none -> e
      | some(t) ->
        let tsub = substitute(t, dests) in
        if t = tsub then e else ("gcast" [e, t, tsub])
  in

  match conclusion(r) with gamma |- ("ci" [e, _]) : t ->

  let r = [name] {
    premises(r)
    ------------------------------------------------------------
    gamma |- ("ci" [e, insert_cast(e)'|filter_es(vars(e))]) : t
  } in
  
  let r = [name] {
    premises(r)(keep)[`&("gjoin" ts)`]:
      if member?(last(ts), vars(t)) then some(self) else none
    ---------------------------------------------------------
    conclusion(r)
  } in

  let join_ts = premises(r)[`&("gjoin" ts)`]: last(ts) in

  let r = [name] {
    premises(r)(keep)[`&("flows" [t1, t2])`]:
      if member?(t2, join_ts) || (t1 = t2) then none else some(t1 ~ t2)
    -------------------------------------------------------------------
    conclusion(r)
  } in

  r
));

add_rule(["T-GCAST"] {
  $Gamma |- $e : $T1,
  $T1 ~ $T2
  ---------------------------------------
  $Gamma |- ("gcast" [$e, $T1, $T2]) : $T2
})
